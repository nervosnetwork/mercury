// Generated by Molecule 0.6.0

use molecule :: prelude :: * ;
use super :: blockchain :: * ;
# [ derive ( Clone ) ] pub struct ScriptVec ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for ScriptVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for ScriptVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for ScriptVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl :: core :: default :: Default for ScriptVec { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 4 , 0 , 0 , 0 , ] ; ScriptVec :: new_unchecked ( v . into ( ) ) } } impl ScriptVec { pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn item_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < Script > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> Script { let slice = self . as_slice ( ) ; let start_idx = molecule :: NUMBER_SIZE * ( 1 + idx ) ; let start = molecule :: unpack_number ( & slice [ start_idx .. ] ) as usize ; if idx == self . len ( ) - 1 { Script :: new_unchecked ( self . 0 . slice ( start .. ) ) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number ( & slice [ end_idx .. ] ) as usize ; Script :: new_unchecked ( self . 0 . slice ( start .. end ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> ScriptVecReader < 'r > { ScriptVecReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for ScriptVec { type Builder = ScriptVecBuilder ; const NAME : & 'static str = "ScriptVec" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { ScriptVec ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { ScriptVecReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { ScriptVecReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . extend ( self . into_iter ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct ScriptVecReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for ScriptVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for ScriptVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for ScriptVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl < 'r > ScriptVecReader < 'r > { pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn item_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < ScriptReader < 'r > > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> ScriptReader < 'r > { let slice = self . as_slice ( ) ; let start_idx = molecule :: NUMBER_SIZE * ( 1 + idx ) ; let start = molecule :: unpack_number ( & slice [ start_idx .. ] ) as usize ; if idx == self . len ( ) - 1 { ScriptReader :: new_unchecked ( & self . as_slice ( ) [ start .. ] ) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number ( & slice [ end_idx .. ] ) as usize ; ScriptReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ScriptVecReader < 'r > { type Entity = ScriptVec ; const NAME : & 'static str = "ScriptVecReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { ScriptVecReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let total_size = molecule :: unpack_number ( slice ) as usize ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok ( ( ) ) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len ) ; } let offset_first = molecule :: unpack_number ( & slice [ molecule :: NUMBER_SIZE .. ] ) as usize ; if offset_first % 4 != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , OffsetsNotMatch ) ; } let item_count = offset_first / 4 - 1 ; let header_size = molecule :: NUMBER_SIZE * ( item_count + 1 ) ; if slice_len < header_size { return ve ! ( Self , HeaderIsBroken , header_size , slice_len ) ; } let mut offsets : Vec < usize > = slice [ molecule :: NUMBER_SIZE .. ] . chunks ( molecule :: NUMBER_SIZE ) . take ( item_count ) . map ( | x | molecule :: unpack_number ( x ) as usize ) . collect ( ) ; offsets . push ( total_size ) ; if offsets . windows ( 2 ) . any ( | i | i [ 0 ] > i [ 1 ] ) { return ve ! ( Self , OffsetsNotMatch ) ; } for pair in offsets . windows ( 2 ) { let start = pair [ 0 ] ; let end = pair [ 1 ] ; ScriptReader :: verify ( & slice [ start .. end ] , compatible ) ? ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct ScriptVecBuilder ( pub ( crate ) Vec < Script > ) ; impl ScriptVecBuilder { pub fn set ( mut self , v : Vec < Script > ) -> Self { self . 0 = v ; self } pub fn push ( mut self , v : Script ) -> Self { self . 0 . push ( v ) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Script >> ( mut self , iter : T ) -> Self { for elem in iter { self . 0 . push ( elem ) ; } self } } impl molecule :: prelude :: Builder for ScriptVecBuilder { type Entity = ScriptVec ; const NAME : & 'static str = "ScriptVecBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . 0 . len ( ) + 1 ) + self . 0 . iter ( ) . map ( | inner | inner . as_slice ( ) . len ( ) ) . sum :: < usize > ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { let item_count = self . 0 . len ( ) ; if item_count == 0 { writer . write_all ( & molecule :: pack_number ( molecule :: NUMBER_SIZE as molecule :: Number ) ) ? ; } else { let ( total_size , offsets ) = self . 0 . iter ( ) . fold ( ( molecule :: NUMBER_SIZE * ( item_count + 1 ) , Vec :: with_capacity ( item_count ) , ) , | ( start , mut offsets ) , inner | { offsets . push ( start ) ; ( start + inner . as_slice ( ) . len ( ) , offsets ) } , ) ; writer . write_all ( & molecule :: pack_number ( total_size as molecule :: Number ) ) ? ; for offset in offsets . into_iter ( ) { writer . write_all ( & molecule :: pack_number ( offset as molecule :: Number ) ) ? ; } for inner in self . 0 . iter ( ) { writer . write_all ( inner . as_slice ( ) ) ? ; } } Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; ScriptVec :: new_unchecked ( inner . into ( ) ) } }
pub struct ScriptVecIterator ( ScriptVec , usize , usize ) ; impl :: core :: iter :: Iterator for ScriptVecIterator { type Item = Script ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl :: core :: iter :: ExactSizeIterator for ScriptVecIterator { fn len ( & self ) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for ScriptVec { type Item = Script ; type IntoIter = ScriptVecIterator ; fn into_iter ( self ) -> Self :: IntoIter { let len = self . len ( ) ; ScriptVecIterator ( self , 0 , len ) } } impl < 'r > ScriptVecReader < 'r > { pub fn iter < 't > ( & 't self ) -> ScriptVecReaderIterator < 't , 'r > { ScriptVecReaderIterator ( & self , 0 , self . len ( ) ) } } pub struct ScriptVecReaderIterator < 't , 'r > ( & 't ScriptVecReader < 'r > , usize , usize ) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for ScriptVecReaderIterator < 't , 'r > { type Item = ScriptReader < 't > ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for ScriptVecReaderIterator < 't , 'r > { fn len ( & self ) -> usize { self . 2 - self . 1 } }
# [ derive ( Clone ) ] pub struct ScriptVecOpt ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for ScriptVecOpt { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for ScriptVecOpt { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for ScriptVecOpt { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { if let Some ( v ) = self . to_opt ( ) { write ! ( f , "{}(Some({}))" , Self :: NAME , v ) } else { write ! ( f , "{}(None)" , Self :: NAME ) } } } impl :: core :: default :: Default for ScriptVecOpt { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ ] ; ScriptVecOpt :: new_unchecked ( v . into ( ) ) } } impl ScriptVecOpt { pub fn is_none ( & self ) -> bool { self . 0 . is_empty ( ) } pub fn is_some ( & self ) -> bool { ! self . 0 . is_empty ( ) } pub fn to_opt ( & self ) -> Option < ScriptVec > { if self . is_none ( ) { None } else { Some ( ScriptVec :: new_unchecked ( self . 0 . clone ( ) ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> ScriptVecOptReader < 'r > { ScriptVecOptReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for ScriptVecOpt { type Builder = ScriptVecOptBuilder ; const NAME : & 'static str = "ScriptVecOpt" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { ScriptVecOpt ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { ScriptVecOptReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { ScriptVecOptReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . set ( self . to_opt ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct ScriptVecOptReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for ScriptVecOptReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for ScriptVecOptReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for ScriptVecOptReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { if let Some ( v ) = self . to_opt ( ) { write ! ( f , "{}(Some({}))" , Self :: NAME , v ) } else { write ! ( f , "{}(None)" , Self :: NAME ) } } } impl < 'r > ScriptVecOptReader < 'r > { pub fn is_none ( & self ) -> bool { self . 0 . is_empty ( ) } pub fn is_some ( & self ) -> bool { ! self . 0 . is_empty ( ) } pub fn to_opt ( & self ) -> Option < ScriptVecReader < 'r > > { if self . is_none ( ) { None } else { Some ( ScriptVecReader :: new_unchecked ( self . as_slice ( ) ) ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for ScriptVecOptReader < 'r > { type Entity = ScriptVecOpt ; const NAME : & 'static str = "ScriptVecOptReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { ScriptVecOptReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { if ! slice . is_empty ( ) { ScriptVecReader :: verify ( & slice [ .. ] , compatible ) ? ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct ScriptVecOptBuilder ( pub ( crate ) Option < ScriptVec > ) ; impl ScriptVecOptBuilder { pub fn set ( mut self , v : Option < ScriptVec > ) -> Self { self . 0 = v ; self } } impl molecule :: prelude :: Builder for ScriptVecOptBuilder { type Entity = ScriptVecOpt ; const NAME : & 'static str = "ScriptVecOptBuilder" ; fn expected_length ( & self ) -> usize { self . 0 . as_ref ( ) . map ( | ref inner | inner . as_slice ( ) . len ( ) ) . unwrap_or ( 0 ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { self . 0 . as_ref ( ) . map ( | ref inner | writer . write_all ( inner . as_slice ( ) ) ) . unwrap_or ( Ok ( ( ) ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; ScriptVecOpt :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct XudtWitnessInput ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for XudtWitnessInput { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for XudtWitnessInput { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for XudtWitnessInput { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "raw_extension_data" , self . raw_extension_data ( ) ) ? ; write ! ( f , ", {}: {}" , "extension_data" , self . extension_data ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl :: core :: default :: Default for XudtWitnessInput { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 16 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , ] ; XudtWitnessInput :: new_unchecked ( v . into ( ) ) } } impl XudtWitnessInput { pub const FIELD_COUNT : usize = 2 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn raw_extension_data ( & self ) -> ScriptVecOpt { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 4 .. ] ) as usize ; let end = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; ScriptVecOpt :: new_unchecked ( self . 0 . slice ( start .. end ) ) } pub fn extension_data ( & self ) -> BytesVec { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & slice [ 12 .. ] ) as usize ; BytesVec :: new_unchecked ( self . 0 . slice ( start .. end ) ) } else { BytesVec :: new_unchecked ( self . 0 . slice ( start .. ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> XudtWitnessInputReader < 'r > { XudtWitnessInputReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for XudtWitnessInput { type Builder = XudtWitnessInputBuilder ; const NAME : & 'static str = "XudtWitnessInput" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { XudtWitnessInput ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { XudtWitnessInputReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { XudtWitnessInputReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . raw_extension_data ( self . raw_extension_data ( ) ) . extension_data ( self . extension_data ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct XudtWitnessInputReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for XudtWitnessInputReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for XudtWitnessInputReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for XudtWitnessInputReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "raw_extension_data" , self . raw_extension_data ( ) ) ? ; write ! ( f , ", {}: {}" , "extension_data" , self . extension_data ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl < 'r > XudtWitnessInputReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn raw_extension_data ( & self ) -> ScriptVecOptReader < 'r > { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 4 .. ] ) as usize ; let end = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; ScriptVecOptReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn extension_data ( & self ) -> BytesVecReader < 'r > { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & slice [ 12 .. ] ) as usize ; BytesVecReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } else { BytesVecReader :: new_unchecked ( & self . as_slice ( ) [ start .. ] ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for XudtWitnessInputReader < 'r > { type Entity = XudtWitnessInput ; const NAME : & 'static str = "XudtWitnessInputReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { XudtWitnessInputReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let total_size = molecule :: unpack_number ( slice ) as usize ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok ( ( ) ) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len ) ; } let offset_first = molecule :: unpack_number ( & slice [ molecule :: NUMBER_SIZE .. ] ) as usize ; if offset_first % 4 != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , OffsetsNotMatch ) ; } let field_count = offset_first / 4 - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ; } ; let header_size = molecule :: NUMBER_SIZE * ( field_count + 1 ) ; if slice_len < header_size { return ve ! ( Self , HeaderIsBroken , header_size , slice_len ) ; } let mut offsets : Vec < usize > = slice [ molecule :: NUMBER_SIZE .. ] . chunks ( molecule :: NUMBER_SIZE ) . take ( field_count ) . map ( | x | molecule :: unpack_number ( x ) as usize ) . collect ( ) ; offsets . push ( total_size ) ; if offsets . windows ( 2 ) . any ( | i | i [ 0 ] > i [ 1 ] ) { return ve ! ( Self , OffsetsNotMatch ) ; } ScriptVecOptReader :: verify ( & slice [ offsets [ 0 ] .. offsets [ 1 ] ] , compatible ) ? ; BytesVecReader :: verify ( & slice [ offsets [ 1 ] .. offsets [ 2 ] ] , compatible ) ? ; Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct XudtWitnessInputBuilder { pub ( crate ) raw_extension_data : ScriptVecOpt , pub ( crate ) extension_data : BytesVec , } impl XudtWitnessInputBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn raw_extension_data ( mut self , v : ScriptVecOpt ) -> Self { self . raw_extension_data = v ; self } pub fn extension_data ( mut self , v : BytesVec ) -> Self { self . extension_data = v ; self } } impl molecule :: prelude :: Builder for XudtWitnessInputBuilder { type Entity = XudtWitnessInput ; const NAME : & 'static str = "XudtWitnessInputBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) + self . raw_extension_data . as_slice ( ) . len ( ) + self . extension_data . as_slice ( ) . len ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { let mut total_size = molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) ; let mut offsets = Vec :: with_capacity ( Self :: FIELD_COUNT ) ; offsets . push ( total_size ) ; total_size += self . raw_extension_data . as_slice ( ) . len ( ) ; offsets . push ( total_size ) ; total_size += self . extension_data . as_slice ( ) . len ( ) ; writer . write_all ( & molecule :: pack_number ( total_size as molecule :: Number ) ) ? ; for offset in offsets . into_iter ( ) { writer . write_all ( & molecule :: pack_number ( offset as molecule :: Number ) ) ? ; } writer . write_all ( self . raw_extension_data . as_slice ( ) ) ? ; writer . write_all ( self . extension_data . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; XudtWitnessInput :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct RCRule ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for RCRule { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for RCRule { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for RCRule { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "smt_root" , self . smt_root ( ) ) ? ; write ! ( f , ", {}: {}" , "flags" , self . flags ( ) ) ? ; write ! ( f , " }}" ) } } impl :: core :: default :: Default for RCRule { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; RCRule :: new_unchecked ( v . into ( ) ) } } impl RCRule { pub const TOTAL_SIZE : usize = 33 ; pub const FIELD_SIZES : [ usize ; 2 ] = [ 32 , 1 , ] ; pub const FIELD_COUNT : usize = 2 ; pub fn smt_root ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 0 .. 32 ) ) } pub fn flags ( & self ) -> Byte { Byte :: new_unchecked ( self . 0 . slice ( 32 .. 33 ) ) } pub fn as_reader < 'r > ( & 'r self ) -> RCRuleReader < 'r > { RCRuleReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for RCRule { type Builder = RCRuleBuilder ; const NAME : & 'static str = "RCRule" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { RCRule ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { RCRuleReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { RCRuleReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . smt_root ( self . smt_root ( ) ) . flags ( self . flags ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct RCRuleReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for RCRuleReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for RCRuleReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for RCRuleReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "smt_root" , self . smt_root ( ) ) ? ; write ! ( f , ", {}: {}" , "flags" , self . flags ( ) ) ? ; write ! ( f , " }}" ) } } impl < 'r > RCRuleReader < 'r > { pub const TOTAL_SIZE : usize = 33 ; pub const FIELD_SIZES : [ usize ; 2 ] = [ 32 , 1 , ] ; pub const FIELD_COUNT : usize = 2 ; pub fn smt_root ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 0 .. 32 ] ) } pub fn flags ( & self ) -> ByteReader < 'r > { ByteReader :: new_unchecked ( & self . as_slice ( ) [ 32 .. 33 ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for RCRuleReader < 'r > { type Entity = RCRule ; const NAME : & 'static str = "RCRuleReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { RCRuleReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len != Self :: TOTAL_SIZE { return ve ! ( Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct RCRuleBuilder { pub ( crate ) smt_root : Byte32 , pub ( crate ) flags : Byte , } impl RCRuleBuilder { pub const TOTAL_SIZE : usize = 33 ; pub const FIELD_SIZES : [ usize ; 2 ] = [ 32 , 1 , ] ; pub const FIELD_COUNT : usize = 2 ; pub fn smt_root ( mut self , v : Byte32 ) -> Self { self . smt_root = v ; self } pub fn flags ( mut self , v : Byte ) -> Self { self . flags = v ; self } } impl molecule :: prelude :: Builder for RCRuleBuilder { type Entity = RCRule ; const NAME : & 'static str = "RCRuleBuilder" ; fn expected_length ( & self ) -> usize { Self :: TOTAL_SIZE } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( self . smt_root . as_slice ( ) ) ? ; writer . write_all ( self . flags . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; RCRule :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct RCCellVec ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for RCCellVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for RCCellVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for RCCellVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl :: core :: default :: Default for RCCellVec { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , ] ; RCCellVec :: new_unchecked ( v . into ( ) ) } } impl RCCellVec { pub const ITEM_SIZE : usize = 32 ; pub fn total_size ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . item_count ( ) + 1 ) } pub fn item_count ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < Byte32 > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> Byte32 { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte32 :: new_unchecked ( self . 0 . slice ( start .. end ) ) } pub fn as_reader < 'r > ( & 'r self ) -> RCCellVecReader < 'r > { RCCellVecReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for RCCellVec { type Builder = RCCellVecBuilder ; const NAME : & 'static str = "RCCellVec" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { RCCellVec ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { RCCellVecReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { RCCellVecReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . extend ( self . into_iter ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct RCCellVecReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for RCCellVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for RCCellVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for RCCellVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl < 'r > RCCellVecReader < 'r > { pub const ITEM_SIZE : usize = 32 ; pub fn total_size ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . item_count ( ) + 1 ) } pub fn item_count ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < Byte32Reader < 'r > > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> Byte32Reader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for RCCellVecReader < 'r > { type Entity = RCCellVec ; const NAME : & 'static str = "RCCellVecReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { RCCellVecReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let item_count = molecule :: unpack_number ( slice ) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! ( Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len ) ; } return Ok ( ( ) ) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct RCCellVecBuilder ( pub ( crate ) Vec < Byte32 > ) ; impl RCCellVecBuilder { pub const ITEM_SIZE : usize = 32 ; pub fn set ( mut self , v : Vec < Byte32 > ) -> Self { self . 0 = v ; self } pub fn push ( mut self , v : Byte32 ) -> Self { self . 0 . push ( v ) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte32 >> ( mut self , iter : T ) -> Self { for elem in iter { self . 0 . push ( elem ) ; } self } } impl molecule :: prelude :: Builder for RCCellVecBuilder { type Entity = RCCellVec ; const NAME : & 'static str = "RCCellVecBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( & molecule :: pack_number ( self . 0 . len ( ) as molecule :: Number ) ) ? ; for inner in & self . 0 [ .. ] { writer . write_all ( inner . as_slice ( ) ) ? ; } Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; RCCellVec :: new_unchecked ( inner . into ( ) ) } }
pub struct RCCellVecIterator ( RCCellVec , usize , usize ) ; impl :: core :: iter :: Iterator for RCCellVecIterator { type Item = Byte32 ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl :: core :: iter :: ExactSizeIterator for RCCellVecIterator { fn len ( & self ) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for RCCellVec { type Item = Byte32 ; type IntoIter = RCCellVecIterator ; fn into_iter ( self ) -> Self :: IntoIter { let len = self . len ( ) ; RCCellVecIterator ( self , 0 , len ) } } impl < 'r > RCCellVecReader < 'r > { pub fn iter < 't > ( & 't self ) -> RCCellVecReaderIterator < 't , 'r > { RCCellVecReaderIterator ( & self , 0 , self . len ( ) ) } } pub struct RCCellVecReaderIterator < 't , 'r > ( & 't RCCellVecReader < 'r > , usize , usize ) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for RCCellVecReaderIterator < 't , 'r > { type Item = Byte32Reader < 't > ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for RCCellVecReaderIterator < 't , 'r > { fn len ( & self ) -> usize { self . 2 - self . 1 } }
# [ derive ( Clone ) ] pub struct RCData ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for RCData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for RCData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for RCData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}(" , Self :: NAME ) ? ; self . to_enum ( ) . display_inner ( f ) ? ; write ! ( f , ")" ) } } impl :: core :: default :: Default for RCData { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; RCData :: new_unchecked ( v . into ( ) ) } } impl RCData { pub const ITEMS_COUNT : usize = 2 ; pub fn item_id ( & self ) -> molecule :: Number { molecule :: unpack_number ( self . as_slice ( ) ) } pub fn to_enum ( & self ) -> RCDataUnion { let inner = self . 0 . slice ( molecule :: NUMBER_SIZE .. ) ; match self . item_id ( ) { 0 => RCRule :: new_unchecked ( inner ) . into ( ) , 1 => RCCellVec :: new_unchecked ( inner ) . into ( ) , _ => panic ! ( "{}: invalid data" , Self :: NAME ) , } } pub fn as_reader < 'r > ( & 'r self ) -> RCDataReader < 'r > { RCDataReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for RCData { type Builder = RCDataBuilder ; const NAME : & 'static str = "RCData" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { RCData ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { RCDataReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { RCDataReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . set ( self . to_enum ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct RCDataReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for RCDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for RCDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for RCDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}(" , Self :: NAME ) ? ; self . to_enum ( ) . display_inner ( f ) ? ; write ! ( f , ")" ) } } impl < 'r > RCDataReader < 'r > { pub const ITEMS_COUNT : usize = 2 ; pub fn item_id ( & self ) -> molecule :: Number { molecule :: unpack_number ( self . as_slice ( ) ) } pub fn to_enum ( & self ) -> RCDataUnionReader < 'r > { let inner = & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ; match self . item_id ( ) { 0 => RCRuleReader :: new_unchecked ( inner ) . into ( ) , 1 => RCCellVecReader :: new_unchecked ( inner ) . into ( ) , _ => panic ! ( "{}: invalid data" , Self :: NAME ) , } } } impl < 'r > molecule :: prelude :: Reader < 'r > for RCDataReader < 'r > { type Entity = RCData ; const NAME : & 'static str = "RCDataReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { RCDataReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let item_id = molecule :: unpack_number ( slice ) ; let inner_slice = & slice [ molecule :: NUMBER_SIZE .. ] ; match item_id { 0 => RCRuleReader :: verify ( inner_slice , compatible ) , 1 => RCCellVecReader :: verify ( inner_slice , compatible ) , _ => ve ! ( Self , UnknownItem , Self :: ITEMS_COUNT , item_id ) , } ? ; Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct RCDataBuilder ( pub ( crate ) RCDataUnion ) ; impl RCDataBuilder { pub const ITEMS_COUNT : usize = 2 ; pub fn set < I > ( mut self , v : I ) -> Self where I : :: core :: convert :: Into < RCDataUnion > { self . 0 = v . into ( ) ; self } } impl molecule :: prelude :: Builder for RCDataBuilder { type Entity = RCData ; const NAME : & 'static str = "RCDataBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE + self . 0 . as_slice ( ) . len ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( & molecule :: pack_number ( self . 0 . item_id ( ) ) ) ? ; writer . write_all ( self . 0 . as_slice ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; RCData :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Debug , Clone ) ] pub enum RCDataUnion { RCRule ( RCRule ) , RCCellVec ( RCCellVec ) , } # [ derive ( Debug , Clone , Copy ) ] pub enum RCDataUnionReader < 'r > { RCRule ( RCRuleReader < 'r > ) , RCCellVec ( RCCellVecReader < 'r > ) , } impl :: core :: default :: Default for RCDataUnion { fn default ( ) -> Self { RCDataUnion :: RCRule ( :: core :: default :: Default :: default ( ) ) } } impl :: core :: fmt :: Display for RCDataUnion { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { match self { RCDataUnion :: RCRule ( ref item ) => { write ! ( f , "{}::{}({})" , Self :: NAME , RCRule :: NAME , item ) } RCDataUnion :: RCCellVec ( ref item ) => { write ! ( f , "{}::{}({})" , Self :: NAME , RCCellVec :: NAME , item ) } } } } impl < 'r > :: core :: fmt :: Display for RCDataUnionReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { match self { RCDataUnionReader :: RCRule ( ref item ) => { write ! ( f , "{}::{}({})" , Self :: NAME , RCRule :: NAME , item ) } RCDataUnionReader :: RCCellVec ( ref item ) => { write ! ( f , "{}::{}({})" , Self :: NAME , RCCellVec :: NAME , item ) } } } } impl RCDataUnion { pub ( crate ) fn display_inner ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { match self { RCDataUnion :: RCRule ( ref item ) => write ! ( f , "{}" , item ) , RCDataUnion :: RCCellVec ( ref item ) => write ! ( f , "{}" , item ) , } } } impl < 'r > RCDataUnionReader < 'r > { pub ( crate ) fn display_inner ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { match self { RCDataUnionReader :: RCRule ( ref item ) => write ! ( f , "{}" , item ) , RCDataUnionReader :: RCCellVec ( ref item ) => write ! ( f , "{}" , item ) , } } } impl :: core :: convert :: From < RCRule > for RCDataUnion { fn from ( item : RCRule ) -> Self { RCDataUnion :: RCRule ( item ) } } impl :: core :: convert :: From < RCCellVec > for RCDataUnion { fn from ( item : RCCellVec ) -> Self { RCDataUnion :: RCCellVec ( item ) } } impl < 'r > :: core :: convert :: From < RCRuleReader < 'r >> for RCDataUnionReader < 'r > { fn from ( item : RCRuleReader < 'r > ) -> Self { RCDataUnionReader :: RCRule ( item ) } } impl < 'r > :: core :: convert :: From < RCCellVecReader < 'r >> for RCDataUnionReader < 'r > { fn from ( item : RCCellVecReader < 'r > ) -> Self { RCDataUnionReader :: RCCellVec ( item ) } } impl RCDataUnion { pub const NAME : & 'static str = "RCDataUnion" ; pub fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { match self { RCDataUnion :: RCRule ( item ) => item . as_bytes ( ) , RCDataUnion :: RCCellVec ( item ) => item . as_bytes ( ) , } } pub fn as_slice ( & self ) -> & [ u8 ] { match self { RCDataUnion :: RCRule ( item ) => item . as_slice ( ) , RCDataUnion :: RCCellVec ( item ) => item . as_slice ( ) , } } pub fn item_id ( & self ) -> molecule :: Number { match self { RCDataUnion :: RCRule ( _ ) => 0 , RCDataUnion :: RCCellVec ( _ ) => 1 , } } pub fn item_name ( & self ) -> & str { match self { RCDataUnion :: RCRule ( _ ) => "RCRule" , RCDataUnion :: RCCellVec ( _ ) => "RCCellVec" , } } pub fn as_reader < 'r > ( & 'r self ) -> RCDataUnionReader < 'r > { match self { RCDataUnion :: RCRule ( item ) => item . as_reader ( ) . into ( ) , RCDataUnion :: RCCellVec ( item ) => item . as_reader ( ) . into ( ) , } } } impl < 'r > RCDataUnionReader < 'r > { pub const NAME : & 'r str = "RCDataUnionReader" ; pub fn as_slice ( & self ) -> & 'r [ u8 ] { match self { RCDataUnionReader :: RCRule ( item ) => item . as_slice ( ) , RCDataUnionReader :: RCCellVec ( item ) => item . as_slice ( ) , } } pub fn item_id ( & self ) -> molecule :: Number { match self { RCDataUnionReader :: RCRule ( _ ) => 0 , RCDataUnionReader :: RCCellVec ( _ ) => 1 , } } pub fn item_name ( & self ) -> & str { match self { RCDataUnionReader :: RCRule ( _ ) => "RCRule" , RCDataUnionReader :: RCCellVec ( _ ) => "RCCellVec" , } } }
# [ derive ( Clone ) ] pub struct SmtProof ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for SmtProof { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for SmtProof { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for SmtProof { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string ( & self . raw_data ( ) ) ; write ! ( f , "{}(0x{})" , Self :: NAME , raw_data ) } } impl :: core :: default :: Default for SmtProof { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , ] ; SmtProof :: new_unchecked ( v . into ( ) ) } } impl SmtProof { pub const ITEM_SIZE : usize = 1 ; pub fn total_size ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . item_count ( ) + 1 ) } pub fn item_count ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < Byte > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> Byte { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte :: new_unchecked ( self . 0 . slice ( start .. end ) ) } pub fn raw_data ( & self ) -> molecule :: bytes :: Bytes { self . 0 . slice ( molecule :: NUMBER_SIZE .. ) } pub fn as_reader < 'r > ( & 'r self ) -> SmtProofReader < 'r > { SmtProofReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for SmtProof { type Builder = SmtProofBuilder ; const NAME : & 'static str = "SmtProof" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { SmtProof ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtProofReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtProofReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . extend ( self . into_iter ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct SmtProofReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for SmtProofReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for SmtProofReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for SmtProofReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string ( & self . raw_data ( ) ) ; write ! ( f , "{}(0x{})" , Self :: NAME , raw_data ) } } impl < 'r > SmtProofReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . item_count ( ) + 1 ) } pub fn item_count ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < ByteReader < 'r > > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> ByteReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ByteReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn raw_data ( & self ) -> & 'r [ u8 ] { & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] } } impl < 'r > molecule :: prelude :: Reader < 'r > for SmtProofReader < 'r > { type Entity = SmtProof ; const NAME : & 'static str = "SmtProofReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { SmtProofReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let item_count = molecule :: unpack_number ( slice ) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! ( Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len ) ; } return Ok ( ( ) ) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct SmtProofBuilder ( pub ( crate ) Vec < Byte > ) ; impl SmtProofBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set ( mut self , v : Vec < Byte > ) -> Self { self . 0 = v ; self } pub fn push ( mut self , v : Byte ) -> Self { self . 0 . push ( v ) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte >> ( mut self , iter : T ) -> Self { for elem in iter { self . 0 . push ( elem ) ; } self } } impl molecule :: prelude :: Builder for SmtProofBuilder { type Entity = SmtProof ; const NAME : & 'static str = "SmtProofBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( & molecule :: pack_number ( self . 0 . len ( ) as molecule :: Number ) ) ? ; for inner in & self . 0 [ .. ] { writer . write_all ( inner . as_slice ( ) ) ? ; } Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; SmtProof :: new_unchecked ( inner . into ( ) ) } }
pub struct SmtProofIterator ( SmtProof , usize , usize ) ; impl :: core :: iter :: Iterator for SmtProofIterator { type Item = Byte ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl :: core :: iter :: ExactSizeIterator for SmtProofIterator { fn len ( & self ) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for SmtProof { type Item = Byte ; type IntoIter = SmtProofIterator ; fn into_iter ( self ) -> Self :: IntoIter { let len = self . len ( ) ; SmtProofIterator ( self , 0 , len ) } }
# [ derive ( Clone ) ] pub struct SmtProofVec ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for SmtProofVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for SmtProofVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for SmtProofVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl :: core :: default :: Default for SmtProofVec { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 4 , 0 , 0 , 0 , ] ; SmtProofVec :: new_unchecked ( v . into ( ) ) } } impl SmtProofVec { pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn item_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < SmtProof > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> SmtProof { let slice = self . as_slice ( ) ; let start_idx = molecule :: NUMBER_SIZE * ( 1 + idx ) ; let start = molecule :: unpack_number ( & slice [ start_idx .. ] ) as usize ; if idx == self . len ( ) - 1 { SmtProof :: new_unchecked ( self . 0 . slice ( start .. ) ) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number ( & slice [ end_idx .. ] ) as usize ; SmtProof :: new_unchecked ( self . 0 . slice ( start .. end ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> SmtProofVecReader < 'r > { SmtProofVecReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for SmtProofVec { type Builder = SmtProofVecBuilder ; const NAME : & 'static str = "SmtProofVec" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { SmtProofVec ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtProofVecReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtProofVecReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . extend ( self . into_iter ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct SmtProofVecReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for SmtProofVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for SmtProofVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for SmtProofVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl < 'r > SmtProofVecReader < 'r > { pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn item_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < SmtProofReader < 'r > > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> SmtProofReader < 'r > { let slice = self . as_slice ( ) ; let start_idx = molecule :: NUMBER_SIZE * ( 1 + idx ) ; let start = molecule :: unpack_number ( & slice [ start_idx .. ] ) as usize ; if idx == self . len ( ) - 1 { SmtProofReader :: new_unchecked ( & self . as_slice ( ) [ start .. ] ) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number ( & slice [ end_idx .. ] ) as usize ; SmtProofReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for SmtProofVecReader < 'r > { type Entity = SmtProofVec ; const NAME : & 'static str = "SmtProofVecReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { SmtProofVecReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let total_size = molecule :: unpack_number ( slice ) as usize ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok ( ( ) ) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len ) ; } let offset_first = molecule :: unpack_number ( & slice [ molecule :: NUMBER_SIZE .. ] ) as usize ; if offset_first % 4 != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , OffsetsNotMatch ) ; } let item_count = offset_first / 4 - 1 ; let header_size = molecule :: NUMBER_SIZE * ( item_count + 1 ) ; if slice_len < header_size { return ve ! ( Self , HeaderIsBroken , header_size , slice_len ) ; } let mut offsets : Vec < usize > = slice [ molecule :: NUMBER_SIZE .. ] . chunks ( molecule :: NUMBER_SIZE ) . take ( item_count ) . map ( | x | molecule :: unpack_number ( x ) as usize ) . collect ( ) ; offsets . push ( total_size ) ; if offsets . windows ( 2 ) . any ( | i | i [ 0 ] > i [ 1 ] ) { return ve ! ( Self , OffsetsNotMatch ) ; } for pair in offsets . windows ( 2 ) { let start = pair [ 0 ] ; let end = pair [ 1 ] ; SmtProofReader :: verify ( & slice [ start .. end ] , compatible ) ? ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct SmtProofVecBuilder ( pub ( crate ) Vec < SmtProof > ) ; impl SmtProofVecBuilder { pub fn set ( mut self , v : Vec < SmtProof > ) -> Self { self . 0 = v ; self } pub fn push ( mut self , v : SmtProof ) -> Self { self . 0 . push ( v ) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = SmtProof >> ( mut self , iter : T ) -> Self { for elem in iter { self . 0 . push ( elem ) ; } self } } impl molecule :: prelude :: Builder for SmtProofVecBuilder { type Entity = SmtProofVec ; const NAME : & 'static str = "SmtProofVecBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . 0 . len ( ) + 1 ) + self . 0 . iter ( ) . map ( | inner | inner . as_slice ( ) . len ( ) ) . sum :: < usize > ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { let item_count = self . 0 . len ( ) ; if item_count == 0 { writer . write_all ( & molecule :: pack_number ( molecule :: NUMBER_SIZE as molecule :: Number ) ) ? ; } else { let ( total_size , offsets ) = self . 0 . iter ( ) . fold ( ( molecule :: NUMBER_SIZE * ( item_count + 1 ) , Vec :: with_capacity ( item_count ) , ) , | ( start , mut offsets ) , inner | { offsets . push ( start ) ; ( start + inner . as_slice ( ) . len ( ) , offsets ) } , ) ; writer . write_all ( & molecule :: pack_number ( total_size as molecule :: Number ) ) ? ; for offset in offsets . into_iter ( ) { writer . write_all ( & molecule :: pack_number ( offset as molecule :: Number ) ) ? ; } for inner in self . 0 . iter ( ) { writer . write_all ( inner . as_slice ( ) ) ? ; } } Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; SmtProofVec :: new_unchecked ( inner . into ( ) ) } }
pub struct SmtProofVecIterator ( SmtProofVec , usize , usize ) ; impl :: core :: iter :: Iterator for SmtProofVecIterator { type Item = SmtProof ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl :: core :: iter :: ExactSizeIterator for SmtProofVecIterator { fn len ( & self ) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for SmtProofVec { type Item = SmtProof ; type IntoIter = SmtProofVecIterator ; fn into_iter ( self ) -> Self :: IntoIter { let len = self . len ( ) ; SmtProofVecIterator ( self , 0 , len ) } } impl < 'r > SmtProofVecReader < 'r > { pub fn iter < 't > ( & 't self ) -> SmtProofVecReaderIterator < 't , 'r > { SmtProofVecReaderIterator ( & self , 0 , self . len ( ) ) } } pub struct SmtProofVecReaderIterator < 't , 'r > ( & 't SmtProofVecReader < 'r > , usize , usize ) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for SmtProofVecReaderIterator < 't , 'r > { type Item = SmtProofReader < 't > ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for SmtProofVecReaderIterator < 't , 'r > { fn len ( & self ) -> usize { self . 2 - self . 1 } }
# [ derive ( Clone ) ] pub struct SmtUpdateItem ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for SmtUpdateItem { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for SmtUpdateItem { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for SmtUpdateItem { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "key" , self . key ( ) ) ? ; write ! ( f , ", {}: {}" , "values" , self . values ( ) ) ? ; write ! ( f , " }}" ) } } impl :: core :: default :: Default for SmtUpdateItem { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; SmtUpdateItem :: new_unchecked ( v . into ( ) ) } } impl SmtUpdateItem { pub const TOTAL_SIZE : usize = 33 ; pub const FIELD_SIZES : [ usize ; 2 ] = [ 32 , 1 , ] ; pub const FIELD_COUNT : usize = 2 ; pub fn key ( & self ) -> Byte32 { Byte32 :: new_unchecked ( self . 0 . slice ( 0 .. 32 ) ) } pub fn values ( & self ) -> Byte { Byte :: new_unchecked ( self . 0 . slice ( 32 .. 33 ) ) } pub fn as_reader < 'r > ( & 'r self ) -> SmtUpdateItemReader < 'r > { SmtUpdateItemReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for SmtUpdateItem { type Builder = SmtUpdateItemBuilder ; const NAME : & 'static str = "SmtUpdateItem" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { SmtUpdateItem ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtUpdateItemReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtUpdateItemReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . key ( self . key ( ) ) . values ( self . values ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct SmtUpdateItemReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for SmtUpdateItemReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for SmtUpdateItemReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for SmtUpdateItemReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "key" , self . key ( ) ) ? ; write ! ( f , ", {}: {}" , "values" , self . values ( ) ) ? ; write ! ( f , " }}" ) } } impl < 'r > SmtUpdateItemReader < 'r > { pub const TOTAL_SIZE : usize = 33 ; pub const FIELD_SIZES : [ usize ; 2 ] = [ 32 , 1 , ] ; pub const FIELD_COUNT : usize = 2 ; pub fn key ( & self ) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked ( & self . as_slice ( ) [ 0 .. 32 ] ) } pub fn values ( & self ) -> ByteReader < 'r > { ByteReader :: new_unchecked ( & self . as_slice ( ) [ 32 .. 33 ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for SmtUpdateItemReader < 'r > { type Entity = SmtUpdateItem ; const NAME : & 'static str = "SmtUpdateItemReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { SmtUpdateItemReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len != Self :: TOTAL_SIZE { return ve ! ( Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct SmtUpdateItemBuilder { pub ( crate ) key : Byte32 , pub ( crate ) values : Byte , } impl SmtUpdateItemBuilder { pub const TOTAL_SIZE : usize = 33 ; pub const FIELD_SIZES : [ usize ; 2 ] = [ 32 , 1 , ] ; pub const FIELD_COUNT : usize = 2 ; pub fn key ( mut self , v : Byte32 ) -> Self { self . key = v ; self } pub fn values ( mut self , v : Byte ) -> Self { self . values = v ; self } } impl molecule :: prelude :: Builder for SmtUpdateItemBuilder { type Entity = SmtUpdateItem ; const NAME : & 'static str = "SmtUpdateItemBuilder" ; fn expected_length ( & self ) -> usize { Self :: TOTAL_SIZE } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( self . key . as_slice ( ) ) ? ; writer . write_all ( self . values . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; SmtUpdateItem :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct SmtUpdateVec ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for SmtUpdateVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for SmtUpdateVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for SmtUpdateVec { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl :: core :: default :: Default for SmtUpdateVec { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 0 , 0 , 0 , 0 , ] ; SmtUpdateVec :: new_unchecked ( v . into ( ) ) } } impl SmtUpdateVec { pub const ITEM_SIZE : usize = 33 ; pub fn total_size ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . item_count ( ) + 1 ) } pub fn item_count ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < SmtUpdateItem > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> SmtUpdateItem { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; SmtUpdateItem :: new_unchecked ( self . 0 . slice ( start .. end ) ) } pub fn as_reader < 'r > ( & 'r self ) -> SmtUpdateVecReader < 'r > { SmtUpdateVecReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for SmtUpdateVec { type Builder = SmtUpdateVecBuilder ; const NAME : & 'static str = "SmtUpdateVec" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { SmtUpdateVec ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtUpdateVecReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtUpdateVecReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . extend ( self . into_iter ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct SmtUpdateVecReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for SmtUpdateVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for SmtUpdateVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for SmtUpdateVecReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} [" , Self :: NAME ) ? ; for i in 0 .. self . len ( ) { if i == 0 { write ! ( f , "{}" , self . get_unchecked ( i ) ) ? ; } else { write ! ( f , ", {}" , self . get_unchecked ( i ) ) ? ; } } write ! ( f , "]" ) } } impl < 'r > SmtUpdateVecReader < 'r > { pub const ITEM_SIZE : usize = 33 ; pub fn total_size ( & self ) -> usize { molecule :: NUMBER_SIZE * ( self . item_count ( ) + 1 ) } pub fn item_count ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn len ( & self ) -> usize { self . item_count ( ) } pub fn is_empty ( & self ) -> bool { self . len ( ) == 0 } pub fn get ( & self , idx : usize ) -> Option < SmtUpdateItemReader < 'r > > { if idx >= self . len ( ) { None } else { Some ( self . get_unchecked ( idx ) ) } } pub fn get_unchecked ( & self , idx : usize ) -> SmtUpdateItemReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; SmtUpdateItemReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } } impl < 'r > molecule :: prelude :: Reader < 'r > for SmtUpdateVecReader < 'r > { type Entity = SmtUpdateVec ; const NAME : & 'static str = "SmtUpdateVecReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { SmtUpdateVecReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , _compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let item_count = molecule :: unpack_number ( slice ) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! ( Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len ) ; } return Ok ( ( ) ) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct SmtUpdateVecBuilder ( pub ( crate ) Vec < SmtUpdateItem > ) ; impl SmtUpdateVecBuilder { pub const ITEM_SIZE : usize = 33 ; pub fn set ( mut self , v : Vec < SmtUpdateItem > ) -> Self { self . 0 = v ; self } pub fn push ( mut self , v : SmtUpdateItem ) -> Self { self . 0 . push ( v ) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = SmtUpdateItem >> ( mut self , iter : T ) -> Self { for elem in iter { self . 0 . push ( elem ) ; } self } } impl molecule :: prelude :: Builder for SmtUpdateVecBuilder { type Entity = SmtUpdateVec ; const NAME : & 'static str = "SmtUpdateVecBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { writer . write_all ( & molecule :: pack_number ( self . 0 . len ( ) as molecule :: Number ) ) ? ; for inner in & self . 0 [ .. ] { writer . write_all ( inner . as_slice ( ) ) ? ; } Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; SmtUpdateVec :: new_unchecked ( inner . into ( ) ) } }
pub struct SmtUpdateVecIterator ( SmtUpdateVec , usize , usize ) ; impl :: core :: iter :: Iterator for SmtUpdateVecIterator { type Item = SmtUpdateItem ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl :: core :: iter :: ExactSizeIterator for SmtUpdateVecIterator { fn len ( & self ) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for SmtUpdateVec { type Item = SmtUpdateItem ; type IntoIter = SmtUpdateVecIterator ; fn into_iter ( self ) -> Self :: IntoIter { let len = self . len ( ) ; SmtUpdateVecIterator ( self , 0 , len ) } } impl < 'r > SmtUpdateVecReader < 'r > { pub fn iter < 't > ( & 't self ) -> SmtUpdateVecReaderIterator < 't , 'r > { SmtUpdateVecReaderIterator ( & self , 0 , self . len ( ) ) } } pub struct SmtUpdateVecReaderIterator < 't , 'r > ( & 't SmtUpdateVecReader < 'r > , usize , usize ) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for SmtUpdateVecReaderIterator < 't , 'r > { type Item = SmtUpdateItemReader < 't > ; fn next ( & mut self ) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked ( self . 1 ) ; self . 1 += 1 ; Some ( ret ) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for SmtUpdateVecReaderIterator < 't , 'r > { fn len ( & self ) -> usize { self . 2 - self . 1 } }
# [ derive ( Clone ) ] pub struct SmtUpdate ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for SmtUpdate { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for SmtUpdate { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for SmtUpdate { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "update" , self . update ( ) ) ? ; write ! ( f , ", {}: {}" , "proof" , self . proof ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl :: core :: default :: Default for SmtUpdate { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 20 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; SmtUpdate :: new_unchecked ( v . into ( ) ) } } impl SmtUpdate { pub const FIELD_COUNT : usize = 2 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn update ( & self ) -> SmtUpdateVec { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 4 .. ] ) as usize ; let end = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; SmtUpdateVec :: new_unchecked ( self . 0 . slice ( start .. end ) ) } pub fn proof ( & self ) -> SmtProof { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & slice [ 12 .. ] ) as usize ; SmtProof :: new_unchecked ( self . 0 . slice ( start .. end ) ) } else { SmtProof :: new_unchecked ( self . 0 . slice ( start .. ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> SmtUpdateReader < 'r > { SmtUpdateReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for SmtUpdate { type Builder = SmtUpdateBuilder ; const NAME : & 'static str = "SmtUpdate" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { SmtUpdate ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtUpdateReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { SmtUpdateReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . update ( self . update ( ) ) . proof ( self . proof ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct SmtUpdateReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for SmtUpdateReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for SmtUpdateReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for SmtUpdateReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "update" , self . update ( ) ) ? ; write ! ( f , ", {}: {}" , "proof" , self . proof ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl < 'r > SmtUpdateReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn update ( & self ) -> SmtUpdateVecReader < 'r > { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 4 .. ] ) as usize ; let end = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; SmtUpdateVecReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn proof ( & self ) -> SmtProofReader < 'r > { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & slice [ 12 .. ] ) as usize ; SmtProofReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } else { SmtProofReader :: new_unchecked ( & self . as_slice ( ) [ start .. ] ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for SmtUpdateReader < 'r > { type Entity = SmtUpdate ; const NAME : & 'static str = "SmtUpdateReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { SmtUpdateReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let total_size = molecule :: unpack_number ( slice ) as usize ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok ( ( ) ) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len ) ; } let offset_first = molecule :: unpack_number ( & slice [ molecule :: NUMBER_SIZE .. ] ) as usize ; if offset_first % 4 != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , OffsetsNotMatch ) ; } let field_count = offset_first / 4 - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ; } ; let header_size = molecule :: NUMBER_SIZE * ( field_count + 1 ) ; if slice_len < header_size { return ve ! ( Self , HeaderIsBroken , header_size , slice_len ) ; } let mut offsets : Vec < usize > = slice [ molecule :: NUMBER_SIZE .. ] . chunks ( molecule :: NUMBER_SIZE ) . take ( field_count ) . map ( | x | molecule :: unpack_number ( x ) as usize ) . collect ( ) ; offsets . push ( total_size ) ; if offsets . windows ( 2 ) . any ( | i | i [ 0 ] > i [ 1 ] ) { return ve ! ( Self , OffsetsNotMatch ) ; } SmtUpdateVecReader :: verify ( & slice [ offsets [ 0 ] .. offsets [ 1 ] ] , compatible ) ? ; SmtProofReader :: verify ( & slice [ offsets [ 1 ] .. offsets [ 2 ] ] , compatible ) ? ; Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct SmtUpdateBuilder { pub ( crate ) update : SmtUpdateVec , pub ( crate ) proof : SmtProof , } impl SmtUpdateBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn update ( mut self , v : SmtUpdateVec ) -> Self { self . update = v ; self } pub fn proof ( mut self , v : SmtProof ) -> Self { self . proof = v ; self } } impl molecule :: prelude :: Builder for SmtUpdateBuilder { type Entity = SmtUpdate ; const NAME : & 'static str = "SmtUpdateBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) + self . update . as_slice ( ) . len ( ) + self . proof . as_slice ( ) . len ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { let mut total_size = molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) ; let mut offsets = Vec :: with_capacity ( Self :: FIELD_COUNT ) ; offsets . push ( total_size ) ; total_size += self . update . as_slice ( ) . len ( ) ; offsets . push ( total_size ) ; total_size += self . proof . as_slice ( ) . len ( ) ; writer . write_all ( & molecule :: pack_number ( total_size as molecule :: Number ) ) ? ; for offset in offsets . into_iter ( ) { writer . write_all ( & molecule :: pack_number ( offset as molecule :: Number ) ) ? ; } writer . write_all ( self . update . as_slice ( ) ) ? ; writer . write_all ( self . proof . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; SmtUpdate :: new_unchecked ( inner . into ( ) ) } }
# [ derive ( Clone ) ] pub struct XudtData ( molecule :: bytes :: Bytes ) ; impl :: core :: fmt :: LowerHex for XudtData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl :: core :: fmt :: Debug for XudtData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl :: core :: fmt :: Display for XudtData { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "lock" , self . lock ( ) ) ? ; write ! ( f , ", {}: {}" , "data" , self . data ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl :: core :: default :: Default for XudtData { fn default ( ) -> Self { let v : Vec < u8 > = vec ! [ 20 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 16 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 4 , 0 , 0 , 0 , ] ; XudtData :: new_unchecked ( v . into ( ) ) } } impl XudtData { pub const FIELD_COUNT : usize = 2 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn lock ( & self ) -> Bytes { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 4 .. ] ) as usize ; let end = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; Bytes :: new_unchecked ( self . 0 . slice ( start .. end ) ) } pub fn data ( & self ) -> BytesVec { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & slice [ 12 .. ] ) as usize ; BytesVec :: new_unchecked ( self . 0 . slice ( start .. end ) ) } else { BytesVec :: new_unchecked ( self . 0 . slice ( start .. ) ) } } pub fn as_reader < 'r > ( & 'r self ) -> XudtDataReader < 'r > { XudtDataReader :: new_unchecked ( self . as_slice ( ) ) } } impl molecule :: prelude :: Entity for XudtData { type Builder = XudtDataBuilder ; const NAME : & 'static str = "XudtData" ; fn new_unchecked ( data : molecule :: bytes :: Bytes ) -> Self { XudtData ( data ) } fn as_bytes ( & self ) -> molecule :: bytes :: Bytes { self . 0 . clone ( ) } fn as_slice ( & self ) -> & [ u8 ] { & self . 0 [ .. ] } fn from_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { XudtDataReader :: from_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn from_compatible_slice ( slice : & [ u8 ] ) -> molecule :: error :: VerificationResult < Self > { XudtDataReader :: from_compatible_slice ( slice ) . map ( | reader | reader . to_entity ( ) ) } fn new_builder ( ) -> Self :: Builder { :: core :: default :: Default :: default ( ) } fn as_builder ( self ) -> Self :: Builder { Self :: new_builder ( ) . lock ( self . lock ( ) ) . data ( self . data ( ) ) } }
# [ derive ( Clone , Copy ) ] pub struct XudtDataReader < 'r > ( & 'r [ u8 ] ) ; impl < 'r > :: core :: fmt :: LowerHex for XudtDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate ( ) { write ! ( f , "0x" ) ? ; } write ! ( f , "{}" , hex_string ( self . as_slice ( ) ) ) } } impl < 'r > :: core :: fmt :: Debug for XudtDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{}({:#x})" , Self :: NAME , self ) } } impl < 'r > :: core :: fmt :: Display for XudtDataReader < 'r > { fn fmt ( & self , f : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { write ! ( f , "{} {{ " , Self :: NAME ) ? ; write ! ( f , "{}: {}" , "lock" , self . lock ( ) ) ? ; write ! ( f , ", {}: {}" , "data" , self . data ( ) ) ? ; let extra_count = self . count_extra_fields ( ) ; if extra_count != 0 { write ! ( f , ", .. ({} fields)" , extra_count ) ? ; } write ! ( f , " }}" ) } } impl < 'r > XudtDataReader < 'r > { pub const FIELD_COUNT : usize = 2 ; pub fn total_size ( & self ) -> usize { molecule :: unpack_number ( self . as_slice ( ) ) as usize } pub fn field_count ( & self ) -> usize { if self . total_size ( ) == molecule :: NUMBER_SIZE { 0 } else { ( molecule :: unpack_number ( & self . as_slice ( ) [ molecule :: NUMBER_SIZE .. ] ) as usize / 4 ) - 1 } } pub fn count_extra_fields ( & self ) -> usize { self . field_count ( ) - Self :: FIELD_COUNT } pub fn has_extra_fields ( & self ) -> bool { Self :: FIELD_COUNT != self . field_count ( ) } pub fn lock ( & self ) -> BytesReader < 'r > { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 4 .. ] ) as usize ; let end = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; BytesReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } pub fn data ( & self ) -> BytesVecReader < 'r > { let slice = self . as_slice ( ) ; let start = molecule :: unpack_number ( & slice [ 8 .. ] ) as usize ; if self . has_extra_fields ( ) { let end = molecule :: unpack_number ( & slice [ 12 .. ] ) as usize ; BytesVecReader :: new_unchecked ( & self . as_slice ( ) [ start .. end ] ) } else { BytesVecReader :: new_unchecked ( & self . as_slice ( ) [ start .. ] ) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for XudtDataReader < 'r > { type Entity = XudtData ; const NAME : & 'static str = "XudtDataReader" ; fn to_entity ( & self ) -> Self :: Entity { Self :: Entity :: new_unchecked ( self . as_slice ( ) . to_owned ( ) . into ( ) ) } fn new_unchecked ( slice : & 'r [ u8 ] ) -> Self { XudtDataReader ( slice ) } fn as_slice ( & self ) -> & 'r [ u8 ] { self . 0 } fn verify ( slice : & [ u8 ] , compatible : bool ) -> molecule :: error :: VerificationResult < ( ) > { use molecule :: verification_error as ve ; let slice_len = slice . len ( ) ; if slice_len < molecule :: NUMBER_SIZE { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len ) ; } let total_size = molecule :: unpack_number ( slice ) as usize ; if slice_len != total_size { return ve ! ( Self , TotalSizeNotMatch , total_size , slice_len ) ; } if slice_len == molecule :: NUMBER_SIZE && Self :: FIELD_COUNT == 0 { return Ok ( ( ) ) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , HeaderIsBroken , molecule :: NUMBER_SIZE * 2 , slice_len ) ; } let offset_first = molecule :: unpack_number ( & slice [ molecule :: NUMBER_SIZE .. ] ) as usize ; if offset_first % 4 != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! ( Self , OffsetsNotMatch ) ; } let field_count = offset_first / 4 - 1 ; if field_count < Self :: FIELD_COUNT { return ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ; } else if ! compatible && field_count > Self :: FIELD_COUNT { return ve ! ( Self , FieldCountNotMatch , Self :: FIELD_COUNT , field_count ) ; } ; let header_size = molecule :: NUMBER_SIZE * ( field_count + 1 ) ; if slice_len < header_size { return ve ! ( Self , HeaderIsBroken , header_size , slice_len ) ; } let mut offsets : Vec < usize > = slice [ molecule :: NUMBER_SIZE .. ] . chunks ( molecule :: NUMBER_SIZE ) . take ( field_count ) . map ( | x | molecule :: unpack_number ( x ) as usize ) . collect ( ) ; offsets . push ( total_size ) ; if offsets . windows ( 2 ) . any ( | i | i [ 0 ] > i [ 1 ] ) { return ve ! ( Self , OffsetsNotMatch ) ; } BytesReader :: verify ( & slice [ offsets [ 0 ] .. offsets [ 1 ] ] , compatible ) ? ; BytesVecReader :: verify ( & slice [ offsets [ 1 ] .. offsets [ 2 ] ] , compatible ) ? ; Ok ( ( ) ) } }
# [ derive ( Debug , Default ) ] pub struct XudtDataBuilder { pub ( crate ) lock : Bytes , pub ( crate ) data : BytesVec , } impl XudtDataBuilder { pub const FIELD_COUNT : usize = 2 ; pub fn lock ( mut self , v : Bytes ) -> Self { self . lock = v ; self } pub fn data ( mut self , v : BytesVec ) -> Self { self . data = v ; self } } impl molecule :: prelude :: Builder for XudtDataBuilder { type Entity = XudtData ; const NAME : & 'static str = "XudtDataBuilder" ; fn expected_length ( & self ) -> usize { molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) + self . lock . as_slice ( ) . len ( ) + self . data . as_slice ( ) . len ( ) } fn write < W : :: molecule :: io :: Write > ( & self , writer : & mut W ) -> :: molecule :: io :: Result < ( ) > { let mut total_size = molecule :: NUMBER_SIZE * ( Self :: FIELD_COUNT + 1 ) ; let mut offsets = Vec :: with_capacity ( Self :: FIELD_COUNT ) ; offsets . push ( total_size ) ; total_size += self . lock . as_slice ( ) . len ( ) ; offsets . push ( total_size ) ; total_size += self . data . as_slice ( ) . len ( ) ; writer . write_all ( & molecule :: pack_number ( total_size as molecule :: Number ) ) ? ; for offset in offsets . into_iter ( ) { writer . write_all ( & molecule :: pack_number ( offset as molecule :: Number ) ) ? ; } writer . write_all ( self . lock . as_slice ( ) ) ? ; writer . write_all ( self . data . as_slice ( ) ) ? ; Ok ( ( ) ) } fn build ( & self ) -> Self :: Entity { let mut inner = Vec :: with_capacity ( self . expected_length ( ) ) ; self . write ( & mut inner ) . unwrap_or_else ( | _ | panic ! ( "{} build should be ok" , Self :: NAME ) ) ; XudtData :: new_unchecked ( inner . into ( ) ) } }
